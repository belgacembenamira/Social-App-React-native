{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"C:\\\\Users\\\\belgacem\\\\OneDrive\\\\Bureau\\\\projet02\\\\SocialApp-React-Native\\\\node_modules\\\\react-native-reanimated\\\\src\\\\createAnimatedComponent.js\";\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport React from 'react';\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport ReanimatedEventEmitter from \"./ReanimatedEventEmitter\";\nimport AnimatedEvent from \"./core/AnimatedEvent\";\nimport AnimatedNode from \"./core/AnimatedNode\";\nimport { createOrReusePropsNode } from \"./core/AnimatedProps\";\nimport invariant from 'fbjs/lib/invariant';\nvar NODE_MAPPING = new Map();\nfunction listener(data) {\n  var component = NODE_MAPPING.get(data.viewTag);\n  component && component._updateFromNative(data.props);\n}\nfunction dummyListener() {}\nexport default function createAnimatedComponent(Component) {\n  invariant(typeof Component !== 'function' || Component.prototype && Component.prototype.isReactComponent, '`createAnimatedComponent` does not support stateless functional components; ' + 'use a class component instead.');\n  var AnimatedComponent = function (_React$Component) {\n    _inherits(AnimatedComponent, _React$Component);\n    var _super = _createSuper(AnimatedComponent);\n    function AnimatedComponent(props) {\n      var _this;\n      _classCallCheck(this, AnimatedComponent);\n      _this = _super.call(this, props);\n      _this._invokeAnimatedPropsCallbackOnMount = false;\n      _this._animatedPropsCallback = function () {\n        if (_this._component == null) {\n          _this._invokeAnimatedPropsCallbackOnMount = true;\n        } else if (typeof _this._component.setNativeProps !== 'function') {\n          _this.forceUpdate();\n        } else {\n          _this._component.setNativeProps(_this._propsAnimated.__getValue());\n        }\n      };\n      _this._setComponentRef = function (c) {\n        if (c !== _this._component) {\n          _this._component = c;\n        }\n      };\n      _this._attachProps(_this.props);\n      return _this;\n    }\n    _createClass(AnimatedComponent, [{\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        this._detachPropUpdater();\n        this._propsAnimated && this._propsAnimated.__detach();\n        this._detachNativeEvents();\n      }\n    }, {\n      key: \"setNativeProps\",\n      value: function setNativeProps(props) {\n        this._component.setNativeProps(props);\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        if (this._invokeAnimatedPropsCallbackOnMount) {\n          this._invokeAnimatedPropsCallbackOnMount = false;\n          this._animatedPropsCallback();\n        }\n        this._propsAnimated.setNativeView(this._component);\n        this._attachNativeEvents();\n        this._attachPropUpdater();\n      }\n    }, {\n      key: \"_getEventViewRef\",\n      value: function _getEventViewRef() {\n        return this._component.getScrollableNode ? this._component.getScrollableNode() : this._component;\n      }\n    }, {\n      key: \"_attachNativeEvents\",\n      value: function _attachNativeEvents() {\n        var node = this._getEventViewRef();\n        for (var key in this.props) {\n          var prop = this.props[key];\n          if (prop instanceof AnimatedEvent) {\n            prop.attachEvent(node, key);\n          }\n        }\n      }\n    }, {\n      key: \"_detachNativeEvents\",\n      value: function _detachNativeEvents() {\n        var node = this._getEventViewRef();\n        for (var key in this.props) {\n          var prop = this.props[key];\n          if (prop instanceof AnimatedEvent) {\n            prop.detachEvent(node, key);\n          }\n        }\n      }\n    }, {\n      key: \"_reattachNativeEvents\",\n      value: function _reattachNativeEvents(prevProps) {\n        var node = this._getEventViewRef();\n        var attached = new Set();\n        var nextEvts = new Set();\n        for (var key in this.props) {\n          var prop = this.props[key];\n          if (prop instanceof AnimatedEvent) {\n            nextEvts.add(prop.__nodeID);\n          }\n        }\n        for (var _key in prevProps) {\n          var _prop = this.props[_key];\n          if (_prop instanceof AnimatedEvent) {\n            if (!nextEvts.has(_prop.__nodeID)) {\n              _prop.detachEvent(node, _key);\n            } else {\n              attached.add(_prop.__nodeID);\n            }\n          }\n        }\n        for (var _key2 in this.props) {\n          var _prop2 = this.props[_key2];\n          if (_prop2 instanceof AnimatedEvent && !attached.has(_prop2.__nodeID)) {\n            _prop2.attachEvent(node, _key2);\n          }\n        }\n      }\n    }, {\n      key: \"_attachProps\",\n      value: function _attachProps(nextProps) {\n        var oldPropsAnimated = this._propsAnimated;\n        this._propsAnimated = createOrReusePropsNode(nextProps, this._animatedPropsCallback, oldPropsAnimated);\n        if (oldPropsAnimated !== this._propsAnimated) {\n          oldPropsAnimated && oldPropsAnimated.__detach();\n        }\n      }\n    }, {\n      key: \"_updateFromNative\",\n      value: function _updateFromNative(props) {\n        this._component.setNativeProps(props);\n      }\n    }, {\n      key: \"_attachPropUpdater\",\n      value: function _attachPropUpdater() {\n        var viewTag = findNodeHandle(this);\n        NODE_MAPPING.set(viewTag, this);\n        if (NODE_MAPPING.size === 1) {\n          ReanimatedEventEmitter.addListener('onReanimatedPropsChange', listener);\n        }\n      }\n    }, {\n      key: \"_detachPropUpdater\",\n      value: function _detachPropUpdater() {\n        var viewTag = findNodeHandle(this);\n        NODE_MAPPING.delete(viewTag);\n        if (NODE_MAPPING.size === 0) {\n          ReanimatedEventEmitter.removeAllListeners('onReanimatedPropsChange');\n        }\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps) {\n        this._attachProps(this.props);\n        this._reattachNativeEvents(prevProps);\n        this._propsAnimated.setNativeView(this._component);\n      }\n    }, {\n      key: \"_filterNonAnimatedStyle\",\n      value: function _filterNonAnimatedStyle(inputStyle) {\n        var style = {};\n        for (var key in inputStyle) {\n          var value = inputStyle[key];\n          if (!(value instanceof AnimatedNode) && key !== 'transform') {\n            style[key] = value;\n          }\n        }\n        return style;\n      }\n    }, {\n      key: \"_filterNonAnimatedProps\",\n      value: function _filterNonAnimatedProps(inputProps) {\n        var props = {};\n        for (var key in inputProps) {\n          var value = inputProps[key];\n          if (key === 'style') {\n            props[key] = this._filterNonAnimatedStyle(StyleSheet.flatten(value));\n          } else if (value instanceof AnimatedEvent) {\n            props[key] = dummyListener;\n          } else if (!(value instanceof AnimatedNode)) {\n            props[key] = value;\n          }\n        }\n        return props;\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var props = this._filterNonAnimatedProps(this.props);\n        var platformProps = Platform.select({\n          web: {},\n          default: {\n            collapsable: false\n          }\n        });\n        return React.createElement(Component, _extends({}, props, {\n          ref: this._setComponentRef\n        }, platformProps, {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 233,\n            columnNumber: 9\n          }\n        }));\n      }\n    }, {\n      key: \"getNode\",\n      value: function getNode() {\n        return this._component;\n      }\n    }]);\n    return AnimatedComponent;\n  }(React.Component);\n  AnimatedComponent.displayName = \"AnimatedComponent(\" + (Component.displayName || Component.name || 'Component') + \")\";\n  return AnimatedComponent;\n}","map":{"version":3,"names":["React","findNodeHandle","Platform","StyleSheet","ReanimatedEventEmitter","AnimatedEvent","AnimatedNode","createOrReusePropsNode","invariant","NODE_MAPPING","Map","listener","data","component","get","viewTag","_updateFromNative","props","dummyListener","createAnimatedComponent","Component","prototype","isReactComponent","AnimatedComponent","_React$Component","_inherits","_super","_createSuper","_this","_classCallCheck","call","_invokeAnimatedPropsCallbackOnMount","_animatedPropsCallback","_component","setNativeProps","forceUpdate","_propsAnimated","__getValue","_setComponentRef","c","_attachProps","_createClass","key","value","componentWillUnmount","_detachPropUpdater","__detach","_detachNativeEvents","componentDidMount","setNativeView","_attachNativeEvents","_attachPropUpdater","_getEventViewRef","getScrollableNode","node","prop","attachEvent","detachEvent","_reattachNativeEvents","prevProps","attached","Set","nextEvts","add","__nodeID","has","nextProps","oldPropsAnimated","set","size","addListener","delete","removeAllListeners","componentDidUpdate","_filterNonAnimatedStyle","inputStyle","style","_filterNonAnimatedProps","inputProps","flatten","render","platformProps","select","web","default","collapsable","createElement","_extends","ref","__source","fileName","_jsxFileName","lineNumber","columnNumber","getNode","displayName","name"],"sources":["C:/Users/belgacem/OneDrive/Bureau/projet02/SocialApp-React-Native/node_modules/react-native-reanimated/src/createAnimatedComponent.js"],"sourcesContent":["import React from 'react';\nimport { findNodeHandle, Platform, StyleSheet } from 'react-native';\nimport ReanimatedEventEmitter from './ReanimatedEventEmitter';\n\nimport AnimatedEvent from './core/AnimatedEvent';\nimport AnimatedNode from './core/AnimatedNode';\nimport { createOrReusePropsNode } from './core/AnimatedProps';\n\nimport invariant from 'fbjs/lib/invariant';\n\nconst NODE_MAPPING = new Map();\n\nfunction listener(data) {\n  const component = NODE_MAPPING.get(data.viewTag);\n  component && component._updateFromNative(data.props);\n}\n\nfunction dummyListener() {\n  // empty listener we use to assign to listener properties for which animated\n  // event is used.\n}\n\nexport default function createAnimatedComponent(Component) {\n  invariant(\n    typeof Component !== 'function' ||\n      (Component.prototype && Component.prototype.isReactComponent),\n    '`createAnimatedComponent` does not support stateless functional components; ' +\n      'use a class component instead.'\n  );\n\n  class AnimatedComponent extends React.Component {\n    _invokeAnimatedPropsCallbackOnMount = false;\n\n    constructor(props) {\n      super(props);\n      this._attachProps(this.props);\n    }\n\n    componentWillUnmount() {\n      this._detachPropUpdater();\n      this._propsAnimated && this._propsAnimated.__detach();\n      this._detachNativeEvents();\n    }\n\n    setNativeProps(props) {\n      this._component.setNativeProps(props);\n    }\n\n    componentDidMount() {\n      if (this._invokeAnimatedPropsCallbackOnMount) {\n        this._invokeAnimatedPropsCallbackOnMount = false;\n        this._animatedPropsCallback();\n      }\n\n      this._propsAnimated.setNativeView(this._component);\n      this._attachNativeEvents();\n      this._attachPropUpdater();\n    }\n\n    _getEventViewRef() {\n      // Make sure to get the scrollable node for components that implement\n      // `ScrollResponder.Mixin`.\n      return this._component.getScrollableNode\n        ? this._component.getScrollableNode()\n        : this._component;\n    }\n\n    _attachNativeEvents() {\n      const node = this._getEventViewRef();\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          prop.attachEvent(node, key);\n        }\n      }\n    }\n\n    _detachNativeEvents() {\n      const node = this._getEventViewRef();\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          prop.detachEvent(node, key);\n        }\n      }\n    }\n\n    _reattachNativeEvents(prevProps) {\n      const node = this._getEventViewRef();\n      const attached = new Set();\n      const nextEvts = new Set();\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          nextEvts.add(prop.__nodeID);\n        }\n      }\n      for (const key in prevProps) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          if (!nextEvts.has(prop.__nodeID)) {\n            // event was in prev props but not in current props, we detach\n            prop.detachEvent(node, key);\n          } else {\n            // event was in prev and is still in current props\n            attached.add(prop.__nodeID);\n          }\n        }\n      }\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent && !attached.has(prop.__nodeID)) {\n          // not yet attached\n          prop.attachEvent(node, key);\n        }\n      }\n    }\n\n    // The system is best designed when setNativeProps is implemented. It is\n    // able to avoid re-rendering and directly set the attributes that changed.\n    // However, setNativeProps can only be implemented on native components\n    // If you want to animate a composite component, you need to re-render it.\n    // In this case, we have a fallback that uses forceUpdate.\n    _animatedPropsCallback = () => {\n      if (this._component == null) {\n        // AnimatedProps is created in will-mount because it's used in render.\n        // But this callback may be invoked before mount in async mode,\n        // In which case we should defer the setNativeProps() call.\n        // React may throw away uncommitted work in async mode,\n        // So a deferred call won't always be invoked.\n        this._invokeAnimatedPropsCallbackOnMount = true;\n      } else if (typeof this._component.setNativeProps !== 'function') {\n        this.forceUpdate();\n      } else {\n        this._component.setNativeProps(this._propsAnimated.__getValue());\n      }\n    };\n\n    _attachProps(nextProps) {\n      const oldPropsAnimated = this._propsAnimated;\n\n      this._propsAnimated = createOrReusePropsNode(\n        nextProps,\n        this._animatedPropsCallback,\n        oldPropsAnimated\n      );\n      // If prop node has been reused we don't need to call into \"__detach\"\n      if (oldPropsAnimated !== this._propsAnimated) {\n        // When you call detach, it removes the element from the parent list\n        // of children. If it goes to 0, then the parent also detaches itself\n        // and so on.\n        // An optimization is to attach the new elements and THEN detach the old\n        // ones instead of detaching and THEN attaching.\n        // This way the intermediate state isn't to go to 0 and trigger\n        // this expensive recursive detaching to then re-attach everything on\n        // the very next operation.\n        oldPropsAnimated && oldPropsAnimated.__detach();\n      }\n    }\n\n    _updateFromNative(props) {\n      this._component.setNativeProps(props);\n    }\n\n    _attachPropUpdater() {\n      const viewTag = findNodeHandle(this);\n      NODE_MAPPING.set(viewTag, this);\n      if (NODE_MAPPING.size === 1) {\n        ReanimatedEventEmitter.addListener('onReanimatedPropsChange', listener);\n      }\n    }\n\n    _detachPropUpdater() {\n      const viewTag = findNodeHandle(this);\n      NODE_MAPPING.delete(viewTag);\n      if (NODE_MAPPING.size === 0) {\n        ReanimatedEventEmitter.removeAllListeners('onReanimatedPropsChange');\n      }\n    }\n\n    componentDidUpdate(prevProps) {\n      this._attachProps(this.props);\n      this._reattachNativeEvents(prevProps);\n\n      this._propsAnimated.setNativeView(this._component);\n    }\n\n    _setComponentRef = c => {\n      if (c !== this._component) {\n        this._component = c;\n      }\n    };\n\n    _filterNonAnimatedStyle(inputStyle) {\n      const style = {};\n      for (const key in inputStyle) {\n        const value = inputStyle[key];\n        if (!(value instanceof AnimatedNode) && key !== 'transform') {\n          style[key] = value;\n        }\n      }\n      return style;\n    }\n\n    _filterNonAnimatedProps(inputProps) {\n      const props = {};\n      for (const key in inputProps) {\n        const value = inputProps[key];\n        if (key === 'style') {\n          props[key] = this._filterNonAnimatedStyle(StyleSheet.flatten(value));\n        } else if (value instanceof AnimatedEvent) {\n          // we cannot filter out event listeners completely as some components\n          // rely on having a callback registered in order to generate events\n          // alltogether. Therefore we provide a dummy callback here to allow\n          // native event dispatcher to hijack events.\n          props[key] = dummyListener;\n        } else if (!(value instanceof AnimatedNode)) {\n          props[key] = value;\n        }\n      }\n      return props;\n    }\n\n    render() {\n      const props = this._filterNonAnimatedProps(this.props);\n      const platformProps = Platform.select({\n        web: {},\n        default: { collapsable: false },\n      });\n      return (\n        <Component {...props} ref={this._setComponentRef} {...platformProps} />\n      );\n    }\n\n    // A third party library can use getNode()\n    // to get the node reference of the decorated component\n    getNode() {\n      return this._component;\n    }\n  }\n\n  AnimatedComponent.displayName = `AnimatedComponent(${Component.displayName || Component.name || 'Component'})`\n\n  return AnimatedComponent;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}